{
  "id": "rp_1769229387611_6wq2vxtu9",
  "timestamp": "2026-01-24T04:36:27.613Z",
  "description": "Auto-backup before changes",
  "files": {
    "C:\\Users\\Admin\\Downloads\\Construction_App\\app\\api\\tiles\\route.ts": "import { NextRequest, NextResponse } from 'next/server'\nimport { withAuth } from '@/lib/withAuth'\nimport { Module, Permission } from '@/lib/permissions/types'\nimport { createServerClient } from '@supabase/ssr'\nimport { getStockOverview } from '@/domains/materials/materialServices'\nimport { withMediumRiskRecovery, withHighRiskRecovery } from '@/lib/errorRecovery'\n\n// Protected GET with auto-backup\nexport const GET = withMediumRiskRecovery(async (request: NextRequest) => {\n  try {\n    const { searchParams } = new URL(request.url)\n    const category = searchParams.get('category')\n    const action = searchParams.get('action')\n    const companyCode = searchParams.get('company_code')\n    const search = searchParams.get('search')\n    const accountType = searchParams.get('account_type')\n    \n    // Handle tiles list request (no category/action)\n    if (!category && !action) {\n      const { createServiceClient } = await import('@/lib/supabase/server')\n      const supabase = await createServiceClient()\n      \n      // Get user and their role\n      const { data: { user }, error: userError } = await supabase.auth.getUser()\n      if (userError || !user) {\n        console.error('Auth error:', userError)\n        return NextResponse.json({ success: true, tiles: [] })\n      }\n      \n      const { data: profile, error: profileError } = await supabase\n        .from('users')\n        .select('*, roles(*)')\n        .eq('id', user.id)\n        .single()\n      \n      if (profileError) {\n        console.error('Profile fetch error:', profileError)\n      }\n      \n      const userRole = profile?.roles?.name\n      console.log('User role:', userRole)\n      \n      // Get user's authorized module codes using RPC function\n      const { data: moduleCodes, error: modulesError } = await supabase\n        .rpc('get_user_modules', { user_id: user.id })\n      \n      if (modulesError) {\n        console.error('RPC error:', modulesError)\n        return NextResponse.json({ success: true, tiles: [] })\n      }\n      \n      const authorizedModuleCodes = moduleCodes?.map((row: any) => row.module_code).filter(Boolean) || []\n      \n      console.log('Authorized module codes:', authorizedModuleCodes)\n      \n      // Fetch only tiles that match user's authorized modules\n      let tilesQuery = supabase\n        .from('tiles')\n        .select('*')\n        .eq('is_active', true)\n      \n      // Fetch only tiles that match user's authorized modules (sorted by category and sequence)\n      if (authorizedModuleCodes.length > 0) {\n        tilesQuery = tilesQuery\n          .in('module_code', authorizedModuleCodes)\n          .order('tile_category', { ascending: true })\n          .order('sequence_order', { ascending: true })\n      } else {\n        return NextResponse.json({ success: true, tiles: [] })\n      }\n      \n      const { data: tiles, error: tilesError } = await tilesQuery.order('id')\n      \n      if (tilesError) {\n        console.error('Tiles fetch error:', tilesError)\n      }\n      \n      console.log('Fetched authorized tiles count:', tiles?.length)\n      \n      return NextResponse.json({\n        success: true,\n        tiles: tiles || []\n      })\n    }\n    \n    // Add RBAC check for tile access\n    const authContext = await withAuth(request, Module.COSTING, Permission.VIEW)\n    \n    // Handle Materials Stock Overview\n    if (category === 'materials' && action === 'stock-overview') {\n      const { getStockOverviewERP } = await import('@/domains/materials/materialMasterService')\n      \n      const filters = {\n        material_category: searchParams.get('material_category'),\n        stock_status: searchParams.get('stock_status')\n      }\n      \n      const data = await getStockOverviewERP(companyCode, filters)\n      \n      return NextResponse.json({\n        success: true,\n        data: data\n      })\n    }\n    \n    // Handle Material Plant Parameters\n    if (category === 'materials' && action === 'plant-parameters') {\n      const { getMaterialPlantData } = await import('@/domains/materials/materialMasterService')\n      \n      const materialCode = searchParams.get('material_code')\n      const plantCode = searchParams.get('plant_code')\n      \n      if (!materialCode) {\n        return NextResponse.json({\n          success: false,\n          error: 'Material code required'\n        }, { status: 400 })\n      }\n      \n      const data = await getMaterialPlantData(materialCode, plantCode || undefined)\n      \n      return NextResponse.json({\n        success: true,\n        data\n      })\n    }\n    \n    // Handle Material Master Display\n    if (category === 'materials' && action === 'material-master') {\n      const { getMaterialMaster } = await import('@/domains/materials/materialMasterService')\n      \n      // Get additional search parameters\n      const materialCategory = searchParams.get('material_category')\n      const materialType = searchParams.get('material_type')\n      \n      const data = await getMaterialMaster(undefined, search || undefined, {\n        category: materialCategory,\n        material_type: materialType\n      })\n      \n      return NextResponse.json({\n        success: true,\n        data: { materials: data }\n      })\n    }\n    \n    // Handle Chart of Accounts - FIXED: Should use Service layer\n    if (category === 'finance' && action === 'chart_of_accounts') {\n      // TODO: Create FinanceService to handle chart of accounts\n      // For now, keeping direct Supabase call as temporary solution\n      const supabase = createServerClient(\n        process.env.NEXT_PUBLIC_SUPABASE_URL!,\n        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n        {\n          cookies: {\n            get(name: string) {\n              return request.cookies.get(name)?.value\n            },\n            set() {},\n            remove() {}\n          }\n        }\n      )\n\n      let query = supabase\n        .from('chart_of_accounts')\n        .select('*')\n        .eq('company_code', companyCode)\n        .order('account_code')\n\n      // Apply search filter\n      if (search) {\n        query = query.or(`account_code.ilike.%${search}%,account_name.ilike.%${search}%`)\n      }\n\n      // Apply account type filter\n      if (accountType && accountType !== 'ALL') {\n        query = query.eq('account_type', accountType)\n      }\n\n      const { data: accounts, error } = await query\n\n      if (error) {\n        return NextResponse.json({\n          success: false,\n          error: error.message\n        }, { status: 500 })\n      }\n\n      // Group accounts by type for grouped view\n      const grouped = (accounts || []).reduce((acc, account) => {\n        if (!acc[account.account_type]) {\n          acc[account.account_type] = []\n        }\n        acc[account.account_type].push(account)\n        return acc\n      }, {} as Record<string, typeof accounts>)\n\n      return NextResponse.json({\n        success: true,\n        data: {\n          accounts: accounts || [],\n          grouped: grouped\n        }\n      })\n    }\n    \n    // Handle Companies from company_codes table\n    if (category === 'finance' && action === 'companies') {\n      const supabase = createServerClient(\n        process.env.NEXT_PUBLIC_SUPABASE_URL!,\n        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n        {\n          cookies: {\n            get(name: string) {\n              return request.cookies.get(name)?.value\n            },\n            set() {},\n            remove() {}\n          }\n        }\n      )\n\n      const { data, error } = await supabase\n        .from('company_codes')\n        .select('company_code, company_name, is_active')\n        .eq('is_active', true)\n        .order('company_code')\n\n      if (error) {\n        return NextResponse.json({\n          success: false,\n          error: error.message\n        }, { status: 500 })\n      }\n\n      const companies = data?.map(company => ({\n        code: company.company_code,\n        name: `${company.company_code} - ${company.company_name}`\n      })) || []\n\n      return NextResponse.json({\n        success: true,\n        data: companies\n      })\n    }\n    \n    // Handle Organisation Configuration\n    if (category === 'organisation' && action === 'organisation-config') {\n      const supabase = createServerClient(\n        process.env.NEXT_PUBLIC_SUPABASE_URL!,\n        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n        {\n          cookies: {\n            get(name: string) {\n              return request.cookies.get(name)?.value\n            },\n            set() {},\n            remove() {}\n          }\n        }\n      )\n\n      const [\n        companyCodes,\n        controllingAreas,\n        plants,\n        costCenters,\n        profitCenters,\n        purchasingOrgs,\n        storageLocations,\n        departments\n      ] = await Promise.all([\n        supabase.from('company_codes').select('*').order('company_code'),\n        supabase.from('controlling_areas').select('*').order('cocarea_code'),\n        supabase.from('plants').select('*').order('plant_code'),\n        supabase.from('cost_centers').select('*').order('cost_center_code'),\n        supabase.from('profit_centers').select('*').order('profit_center_code'),\n        supabase.from('purchasing_organizations').select('*').order('porg_code'),\n        supabase.from('storage_locations').select('*').order('sloc_code'),\n        supabase.from('departments').select('*').order('name')\n      ])\n\n      return NextResponse.json({\n        success: true,\n        data: {\n          companyCodes: companyCodes.data || [],\n          controllingAreas: controllingAreas.data || [],\n          plants: plants.data || [],\n          costCenters: costCenters.data || [],\n          profitCenters: profitCenters.data || [],\n          purchasingOrgs: purchasingOrgs.data || [],\n          storageLocations: storageLocations.data || [],\n          departments: departments.data || []\n        }\n      })\n    }\n    \n    return NextResponse.json({\n      success: true,\n      category,\n      action,\n      userRole: authContext.userRole,\n      data: { message: `${category}/${action} functionality available` }\n    })\n\n  } catch (error) {\n    if (error instanceof Error && (error.message === 'Unauthorized' || error.message === 'Forbidden')) {\n      return NextResponse.json({ error: error.message }, { status: error.message === 'Unauthorized' ? 401 : 403 })\n    }\n    \n    return NextResponse.json({\n      error: 'Tile execution failed',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 })\n  }\n})\n\n// Protected POST with auto-backup and rollback\nexport const POST = withHighRiskRecovery(async (request: NextRequest) => {\n  try {\n    const authContext = await withAuth(request, Module.COSTING, Permission.CREATE)\n    const body = await request.json()\n    \n    // Get category and action from body (not searchParams)\n    const category = body.category\n    const action = body.action\n    \n    console.log('POST request - category:', category, 'action:', action, 'body:', body)\n    \n    if (category === 'finance' && action === 'chart_of_accounts') {\n      // TODO: Create FinanceService to handle chart of accounts operations\n      // For now, keeping direct Supabase call as temporary solution\n      const supabase = createServerClient(\n        process.env.NEXT_PUBLIC_SUPABASE_URL!,\n        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n        {\n          cookies: {\n            get(name: string) {\n              return request.cookies.get(name)?.value\n            },\n            set() {},\n            remove() {}\n          }\n        }\n      )\n\n      const { data, error } = await supabase\n        .from('chart_of_accounts')\n        .insert([body])\n        .select()\n        .single()\n\n      if (error) {\n        return NextResponse.json({\n          success: false,\n          error: error.message\n        }, { status: 500 })\n      }\n\n      return NextResponse.json({\n        success: true,\n        data: { account: data }\n      })\n    }\n    \n    // Handle Approval Configuration - FIXED: Only call Service layer\n    if (category === 'approval' && action === 'configuration') {\n      const { ApprovalService } = await import('@/domains/approval/ApprovalService')\n      \n      if (body.action === 'get-field-definitions') {\n        const result = await ApprovalService.getFieldDefinitions(body.customer_id)\n        return NextResponse.json(result)\n      }\n      \n      if (body.action === 'get-document-types') {\n        const result = await ApprovalService.getDocumentTypes(body.customer_id)\n        return NextResponse.json(result)\n      }\n      \n      if (body.action === 'create-policy') {\n        const result = await ApprovalService.createPolicy(body.policy)\n        return NextResponse.json(result)\n      }\n      \n      if (body.action === 'get-policies') {\n        const result = await ApprovalService.getApprovalPoliciesPaginated(body.filters)\n        return NextResponse.json(result)\n      }\n      \n      if (body.action === 'get-approvers') {\n        const result = await ApprovalService.getApprovers(body.filters)\n        return NextResponse.json(result)\n      }\n      \n      if (body.action === 'generate-flow') {\n        const result = await ApprovalService.generateUniversalFlow(body.request)\n        return NextResponse.json(result)\n      }\n    }\n    \n    // Handle Chart of Accounts Operations\n    if (body.action === 'copyChartOfAccounts' || (category === 'finance' && action === 'copy_chart') || body.action === 'copy_chart') {\n      const { FinanceService } = await import('@/domains/finance/FinanceService')\n      const financeService = new FinanceService()\n      \n      const result = await financeService.copyChartOfAccounts(\n        body.source_company,\n        body.target_company\n      )\n      \n      return NextResponse.json({\n        success: true,\n        data: {\n          count: result.count,\n          recordsCopied: result.count\n        }\n      })\n    }\n    \n    // Handle Finance Master Data requests\n    if (category === 'finance') {\n      const { FinanceService } = await import('@/domains/finance/FinanceService')\n      const financeService = new FinanceService()\n      \n      if (action === 'cost_centers') {\n        const data = await financeService.getCostCenters(body.company_code)\n        return NextResponse.json({ success: true, data })\n      }\n      \n      if (action === 'wbs_elements') {\n        const data = await financeService.getWBSElements(body.company_code)\n        return NextResponse.json({ success: true, data })\n      }\n      \n      if (action === 'profit_centers') {\n        const data = await financeService.getProfitCenters(body.company_code)\n        return NextResponse.json({ success: true, data })\n      }\n      \n      if (action === 'companies') {\n        const data = await financeService.getCompanies()\n        return NextResponse.json({ success: true, data })\n      }\n    }\n    \n    // Handle Projects CRUD\n    if (body.category === 'projects') {\n      console.log('Handling projects request:', body)\n      const { handleProjects } = await import('@/app/api/projects/handler')\n      \n      try {\n        if (body.action === 'list') {\n          const data = await handleProjects('list', body.payload || {}, 'GET')\n          return NextResponse.json({ success: true, data })\n        }\n        \n        if (body.action === 'create') {\n          const payloadWithUser = { ...body.payload, userId: authContext.userId }\n          const data = await handleProjects('create', payloadWithUser, 'POST')\n          return NextResponse.json({ success: true, data })\n        }\n        \n        if (body.action === 'update') {\n          const payloadWithUser = { ...body.payload, userId: authContext.userId }\n          const data = await handleProjects('update', payloadWithUser, 'POST')\n          return NextResponse.json({ success: true, data })\n        }\n        \n        if (body.action === 'delete') {\n          const data = await handleProjects('delete', body.payload, 'POST')\n          return NextResponse.json({ success: true, data })\n        }\n        \n        // Handle other project actions (categories, patterns, etc.)\n        const data = await handleProjects(body.action, body.payload || {}, 'GET')\n        return NextResponse.json({ success: true, data })\n      } catch (projectError) {\n        console.error('Projects handler error:', projectError)\n        throw projectError\n      }\n    }\n    \n    // Handle Material Master Operations\n    if (body.category === 'materials') {\n      const { createMaterialMaster, getMaterialMaster, updateMaterialMaster, extendMaterialToPlant } = await import('@/domains/materials/materialMasterService')\n      const { unifiedMaterialRequestService } = await import('@/domains/materials/unifiedMaterialRequestService')\n\n      // Unified Material Request handlers\n      if (body.action === 'unified-material-request') {\n        const data = await unifiedMaterialRequestService.createMaterialRequest(body.payload, authContext.userId)\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'material-request-list') {\n        const data = await unifiedMaterialRequestService.getMaterialRequests(body.payload || {})\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'get-material-request') {\n        const data = await unifiedMaterialRequestService.getMaterialRequestById(body.payload.id)\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'approve-material-request') {\n        const data = await unifiedMaterialRequestService.updateRequestStatus(\n          body.payload.request_id,\n          body.payload.status,\n          authContext.userId,\n          body.payload.comments\n        )\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'delete-material-request') {\n        const data = await unifiedMaterialRequestService.deleteMaterialRequest(body.payload.id)\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'get-templates') {\n        const data = await unifiedMaterialRequestService.getRequestTemplates(body.payload?.template_type)\n        return NextResponse.json(data)\n      }\n\n      // Flexible Approval System handlers\n      if (body.action === 'get-approval-templates') {\n        const { flexibleApprovalService } = await import('@/domains/materials/flexibleApprovalService')\n        const data = await flexibleApprovalService.getApprovalTemplates(body.payload?.customer_type, body.payload?.industry_type)\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'apply-approval-template') {\n        const { flexibleApprovalService } = await import('@/domains/materials/flexibleApprovalService')\n        const data = await flexibleApprovalService.applyApprovalTemplate(\n          body.payload.customer_id,\n          body.payload.document_type,\n          body.payload.template_id,\n          body.payload.config_name\n        )\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'get-approval-levels') {\n        const { flexibleApprovalService } = await import('@/domains/materials/flexibleApprovalService')\n        const data = await flexibleApprovalService.getCustomerApprovalLevels(\n          body.payload.customer_id,\n          body.payload.document_type\n        )\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'create-approval-level') {\n        const { flexibleApprovalService } = await import('@/domains/materials/flexibleApprovalService')\n        const data = await flexibleApprovalService.createCustomApprovalLevel(\n          body.payload.customer_id,\n          body.payload.document_type,\n          body.payload.level_data\n        )\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'get-approval-path') {\n        const { flexibleApprovalService } = await import('@/domains/materials/flexibleApprovalService')\n        const data = await flexibleApprovalService.getApprovalPath(\n          body.payload.customer_id,\n          body.payload.document_type,\n          body.payload.amount,\n          body.payload.category,\n          body.payload.department\n        )\n        return NextResponse.json(data)\n      }\n\n      if (body.action === 'create-material') {\n        const data = await createMaterialMaster(body.payload, authContext.userId)\n        \n        return NextResponse.json({\n          success: true,\n          data: { material: data }\n        })\n      }\n\n      if (body.action === 'maintain-material') {\n        console.log('Maintain material request:', body.payload) // Debug log\n        \n        if (body.payload.material_id && !body.payload.material_name) {\n          // Search for material\n          console.log('Searching for material:', body.payload.material_id) // Debug log\n          const materials = await getMaterialMaster(body.payload.material_id)\n          console.log('Materials found:', materials) // Debug log\n          const material = materials[0]\n          \n          if (!material) {\n            console.log('Material not found in database') // Debug log\n            return NextResponse.json({\n              success: false,\n              error: 'Material not found'\n            }, { status: 404 })\n          }\n\n          return NextResponse.json({\n            success: true,\n            data: { material }\n          })\n        } else {\n          // Update material\n          const data = await updateMaterialMaster(\n            body.payload.material_id,\n            {\n              material_name: body.payload.material_name,\n              description: body.payload.description\n            },\n            authContext.userId\n          )\n\n          return NextResponse.json({\n            success: true,\n            data: { material: data }\n          })\n        }\n      }\n\n      if (body.action === 'extend-to-plant') {\n        // Get material and plant IDs first\n        const supabase = createServerClient(\n          process.env.NEXT_PUBLIC_SUPABASE_URL!,\n          process.env.SUPABASE_SERVICE_ROLE_KEY!,\n          {\n            cookies: {\n              get(name: string) {\n                return request.cookies.get(name)?.value\n              },\n              set() {},\n              remove() {}\n            }\n          }\n        )\n        \n        const { data: material } = await supabase\n          .from('materials')\n          .select('id')\n          .eq('material_code', body.payload.material_code)\n          .single()\n          \n        const { data: plant } = await supabase\n          .from('plants')\n          .select('id')\n          .eq('plant_code', body.payload.plant_code)\n          .single()\n          \n        if (!material || !plant) {\n          return NextResponse.json({\n            success: false,\n            error: 'Material or Plant not found'\n          }, { status: 404 })\n        }\n        \n        const extendData = {\n          ...body.payload,\n          material_id: material.id,\n          plant_id: plant.id,\n          plant_status: 'ACTIVE',\n          is_active: true\n        }\n        \n        const data = await extendMaterialToPlant(extendData, authContext.userId)\n        \n        return NextResponse.json({\n          success: true,\n          data: { extension: data }\n        })\n      }\n    }\n    \n    return NextResponse.json({\n      success: true,\n      data: { message: 'Created successfully' }\n    })\n  } catch (error) {\n    console.error('POST /api/tiles error:', error)\n    console.error('Error stack:', error instanceof Error ? error.stack : 'No stack trace')\n    return NextResponse.json({\n      error: 'Creation failed',\n      details: error instanceof Error ? error.message : 'Unknown error',\n      stack: error instanceof Error ? error.stack : undefined\n    }, { status: 500 })\n  }\n})\n\nexport async function PUT(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const category = searchParams.get('category')\n    const action = searchParams.get('action')\n    const id = searchParams.get('id')\n    \n    const authContext = await withAuth(request, Module.COSTING, Permission.EDIT)\n    const body = await request.json()\n    \n    if (category === 'finance' && action === 'chart_of_accounts' && id) {\n      const supabase = createServerClient(\n        process.env.NEXT_PUBLIC_SUPABASE_URL!,\n        process.env.SUPABASE_SERVICE_ROLE_KEY!,\n        {\n          cookies: {\n            get(name: string) {\n              return request.cookies.get(name)?.value\n            },\n            set() {},\n            remove() {}\n          }\n        }\n      )\n\n      const { data, error } = await supabase\n        .from('chart_of_accounts')\n        .update(body)\n        .eq('id', id)\n        .select()\n        .single()\n\n      if (error) {\n        return NextResponse.json({\n          success: false,\n          error: error.message\n        }, { status: 500 })\n      }\n\n      return NextResponse.json({\n        success: true,\n        data: { account: data }\n      })\n    }\n    \n    return NextResponse.json({\n      success: true,\n      data: { message: 'Updated successfully' }\n    })\n  } catch (error) {\n    return NextResponse.json({\n      error: 'Update failed',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 })\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const category = searchParams.get('category')\n    const action = searchParams.get('action')\n    const id = searchParams.get('id')\n    \n    const authContext = await withAuth(request, Module.COSTING, Permission.DELETE)\n    \n    if (category === 'finance' && action === 'chart_of_accounts' && id) {\n      const supabase = createServerClient(\n        process.env.NEXT_PUBLIC_SUPABASE_URL!,\n        process.env.SUPABASE_SERVICE_ROLE_KEY!,\n        {\n          cookies: {\n            get(name: string) {\n              return request.cookies.get(name)?.value\n            },\n            set() {},\n            remove() {}\n          }\n        }\n      )\n\n      const { error } = await supabase\n        .from('chart_of_accounts')\n        .delete()\n        .eq('id', id)\n\n      if (error) {\n        return NextResponse.json({\n          success: false,\n          error: error.message\n        }, { status: 500 })\n      }\n\n      return NextResponse.json({\n        success: true,\n        data: { message: `Account deleted successfully` }\n      })\n    }\n    \n    return NextResponse.json({\n      success: true,\n      data: { message: 'Deleted successfully' }\n    })\n  } catch (error) {\n    return NextResponse.json({\n      error: 'Deletion failed',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 })\n  }\n}",
    "C:\\Users\\Admin\\Downloads\\Construction_App\\domains\\approval\\ApprovalService.ts": "// Layer 2: Business Logic Layer - domains/approval/ApprovalService.ts\nimport { ApprovalRepository } from './approvalRepository';\n\n// Default customer ID - should be passed from request context in production\nconst DEFAULT_CUSTOMER_ID = '550e8400-e29b-41d4-a716-446655440001';\n\nexport class ApprovalService {\n  private static validateCustomerId(customerId: string): void {\n    if (!customerId || typeof customerId !== 'string' || customerId.length < 10) {\n      throw new Error('Invalid customer ID');\n    }\n  }\n\n  private static sanitizeInput(input: any): any {\n    if (typeof input === 'string') {\n      return input.trim().substring(0, 1000);\n    }\n    if (typeof input === 'object' && input !== null) {\n      const sanitized: any = {};\n      Object.keys(input).forEach(key => {\n        if (typeof input[key] === 'string') {\n          sanitized[key] = input[key].trim().substring(0, 1000);\n        } else {\n          sanitized[key] = input[key];\n        }\n      });\n      return sanitized;\n    }\n    return input;\n  }\n  // Field definitions service method\n  static async getFieldDefinitions(customerId: string) {\n    console.log('Business layer: Getting field definitions for customer:', customerId);\n    \n    try {\n      this.validateCustomerId(customerId);\n      const fields = await ApprovalRepository.getFieldDefinitions(customerId);\n      return { success: true, data: fields };\n    } catch (error) {\n      console.error('Business layer error fetching field definitions:', error);\n      return { success: false, data: [], message: error instanceof Error ? error.message : 'Failed to fetch field definitions' };\n    }\n  }\n\n  // Document types service method\n  static async getDocumentTypes(customerId: string) {\n    console.log('Business layer: Getting document types for customer:', customerId);\n    \n    try {\n      this.validateCustomerId(customerId);\n      const documentTypes = await ApprovalRepository.getDocumentTypes(customerId);\n      return { success: true, data: documentTypes };\n    } catch (error) {\n      console.error('Business layer error fetching document types:', error);\n      return { success: false, data: [], message: error instanceof Error ? error.message : 'Failed to fetch document types' };\n    }\n  }\n\n  // Business logic: Add customer context and policy naming with validation\n  static async createPolicy(data: any) {\n    console.log('Business layer: Creating approval policy:', data);\n    \n    try {\n      if (!data?.approval_object_type || !data?.approval_object_document_type) {\n        return { success: false, message: 'Missing required fields: object type and document type' };\n      }\n\n      const sanitizedData = this.sanitizeInput(data);\n      \n      // Map field names to database columns\n      const fieldMapping = {\n        'selected_country_code': 'selected_countries',\n        'selected_department_code': 'selected_departments', \n        'selected_plant_code': 'selected_plants',\n        'selected_storage_location_code': 'selected_storage_locations',\n        'selected_purchase_org': 'selected_purchase_orgs',\n        'selected_project_code': 'selected_projects'\n      };\n      \n      // Transform field names\n      const transformedData = { ...sanitizedData };\n      Object.keys(fieldMapping).forEach(oldKey => {\n        if (transformedData[oldKey] !== undefined) {\n          transformedData[fieldMapping[oldKey]] = transformedData[oldKey];\n          delete transformedData[oldKey];\n        }\n      });\n      \n      // Business rule: Auto-generate policy name and add customer context\n      const enrichedPolicy = {\n        customer_id: customerId || DEFAULT_CUSTOMER_ID,\n        policy_name: `${transformedData.approval_object_type} ${transformedData.approval_object_document_type} Policy`,\n        ...transformedData\n      };\n      \n      const policy = await ApprovalRepository.createApprovalPolicy(enrichedPolicy);\n      return { success: true, message: 'Policy created successfully', policy };\n    } catch (error) {\n      console.error('Business layer error creating policy:', error);\n      return { success: false, message: error instanceof Error ? error.message : 'Failed to create policy' };\n    }\n  }\n\n  // Enhanced universal flow generation with validation\n  static async generateUniversalFlow(data: any) {\n    console.log('Universal approval flow generation:', data);\n    \n    try {\n      if (!data?.object_type) {\n        return { success: false, error: 'Object type is required' };\n      }\n\n      const sanitizedData = this.sanitizeInput(data);\n      const customerId = sanitizedData.customer_id || DEFAULT_CUSTOMER_ID;\n      this.validateCustomerId(customerId);\n      \n      // 1. Get object type configuration\n      const objectTypes = await ApprovalRepository.getObjectTypes(CUSTOMER_ID);\n      const objectType = objectTypes.find(ot => ot.object_type === sanitizedData.object_type);\n      \n      if (!objectType) {\n        return { success: false, error: 'Unknown object type' };\n      }\n      \n      // 2. Find matching policy with enhanced context scoring\n      const policies = await ApprovalRepository.getApprovalPolicies(CUSTOMER_ID);\n      const policy = this.findBestMatchingPolicy(policies, sanitizedData, objectType);\n      \n      if (!policy) {\n        return { success: false, error: 'No matching policy found' };\n      }\n      \n      // 3. Generate category-specific approval flow\n      const flow = await this.generateCategorySpecificFlow(policy, sanitizedData, objectType, customerId);\n      \n      return {\n        success: true,\n        policy: policy.policy_name,\n        strategy: policy.approval_strategy,\n        object_category: policy.object_category || objectType.object_category,\n        flow: flow,\n        total_steps: flow.length,\n        estimated_time: this.calculateEstimatedTime(policy, flow)\n      };\n      \n    } catch (error) {\n      console.error('Error generating universal flow:', error);\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to generate approval flow' };\n    }\n  }\n\n  // Enhanced policy matching with sparse context scoring\n  private static findBestMatchingPolicy(policies: any[], data: any, objectType: any) {\n    const candidates = policies.filter(p => \n      p.approval_object_type === data.object_type &&\n      (p.object_category === objectType.object_category || !p.object_category)\n    );\n    \n    if (candidates.length === 0) return null;\n    if (candidates.length === 1) return candidates[0];\n    \n    // Score policies based on sparse context specificity\n    const scoredPolicies = candidates.map(policy => ({\n      policy,\n      score: this.calculateSparseContextScore(policy, data)\n    }));\n    \n    scoredPolicies.sort((a, b) => b.score - a.score);\n    return scoredPolicies[0].policy;\n  }\n\n  // Enhanced sparse context scoring with hierarchical weights\n  private static calculateSparseContextScore(policy: any, data: any): number {\n    let score = 0;\n    let specificity = 0;\n    \n    const contextFields = [\n      { policy: 'selected_countries', request: 'country_code', weight: 120 },\n      { policy: 'selected_departments', request: 'department_code', weight: 100 },\n      { policy: 'selected_plants', request: 'plant_code', weight: 80 },\n      { policy: 'selected_storage_locations', request: 'storage_location_code', weight: 60 },\n      { policy: 'selected_purchase_orgs', request: 'purchase_org', weight: 40 },\n      { policy: 'selected_projects', request: 'project_code', weight: 20 }\n    ];\n    \n    for (const field of contextFields) {\n      const policyValue = policy[field.policy];\n      const requestValue = data[field.request];\n      \n      if (policyValue === null || policyValue === undefined) {\n        // NULL = Global (matches everything, low specificity)\n        score += field.weight / 10;\n      } else if (Array.isArray(policyValue)) {\n        if (policyValue.length === 0) {\n          // Empty array = Disabled (no match)\n          return -10000;\n        } else if (policyValue.includes(requestValue)) {\n          // Exact match in array (high specificity)\n          score += field.weight * 10;\n          specificity += field.weight / 20;\n        } else if (requestValue) {\n          // Request has value but policy doesn't match\n          score -= field.weight * 5;\n        }\n      } else if (policyValue === requestValue) {\n        // Exact scalar match\n        score += field.weight * 10;\n        specificity += field.weight / 20;\n      } else if (policyValue && requestValue && policyValue !== requestValue) {\n        // Mismatch penalty\n        score -= field.weight * 5;\n      }\n    }\n    \n    // Bonus for higher specificity with hierarchical weighting\n    score += specificity * 25;\n    return score;\n  }\n\n  // Category-specific flow generation\n  private static async generateCategorySpecificFlow(policy: any, data: any, objectType: any, customerId: string) {\n    const category = policy.object_category || objectType.object_category;\n    \n    switch (category) {\n      case 'FINANCIAL':\n        return this.generateFinancialFlow(policy, data, customerId);\n      case 'DOCUMENT':\n        return this.generateDocumentFlow(policy, data, customerId);\n      case 'STORAGE':\n        return this.generateStorageFlow(policy, data, customerId);\n      case 'TRAVEL':\n        return this.generateTravelFlow(policy, data, customerId);\n      case 'HR':\n        return this.generateHRFlow(policy, data, customerId);\n      default:\n        return this.generateDefaultFlow(policy, data, customerId);\n    }\n  }\n\n  // Financial flow generation (enhanced existing logic)\n  private static async generateFinancialFlow(policy: any, data: any, customerId: string) {\n    const amount = data.amount || 0;\n    \n    if (policy.approval_strategy === 'AMOUNT_BASED') {\n      const approvers = await ApprovalRepository.getFunctionalApprovers(customerId);\n      const suitableApprover = approvers\n        .filter(a => a.functional_domain === 'FINANCE' && amount <= a.approval_limit)\n        .sort((a, b) => a.approval_limit - b.approval_limit)[0];\n      \n      return suitableApprover ? [{\n        step: 1,\n        approver_role: suitableApprover.approver_role,\n        level_name: `${suitableApprover.approval_scope} Approval`,\n        amount_limit: suitableApprover.approval_limit,\n        required: true\n      }] : [];\n    }\n    \n    return this.generateHierarchicalFlow(policy, data, customerId);\n  }\n\n  // Document flow generation\n  private static async generateDocumentFlow(policy: any, data: any, customerId: string) {\n    const flow = [];\n    const discipline = data.discipline || policy.document_discipline;\n    \n    if (discipline === 'STRUCTURAL') {\n      flow.push({ step: 1, approver_role: 'Structural Engineer', level_name: 'Technical Review', required: true });\n      flow.push({ step: 2, approver_role: 'Chief Engineer', level_name: 'Senior Review', required: true });\n    } else if (discipline === 'MECHANICAL') {\n      flow.push({ step: 1, approver_role: 'MEP Engineer', level_name: 'Technical Review', required: true });\n      flow.push({ step: 2, approver_role: 'Design Manager', level_name: 'Design Review', required: true });\n    } else {\n      flow.push({ step: 1, approver_role: 'Technical Lead', level_name: 'Technical Review', required: true });\n    }\n    \n    if (data.regulatory_impact || policy.approval_context?.regulatory_impact) {\n      flow.push({ step: flow.length + 1, approver_role: 'Regulatory Authority', level_name: 'Regulatory Review', required: true });\n    }\n    \n    return flow;\n  }\n\n  // Storage flow generation\n  private static async generateStorageFlow(policy: any, data: any, customerId: string) {\n    const flow = [];\n    const storageType = data.storage_type || policy.storage_type;\n    \n    if (storageType === 'HAZMAT') {\n      flow.push({ step: 1, approver_role: 'Safety Officer', level_name: 'Safety Review', required: true });\n      flow.push({ step: 2, approver_role: 'Fire Marshal', level_name: 'Fire Safety Review', required: true });\n    } else if (storageType === 'SECURE') {\n      flow.push({ step: 1, approver_role: 'Security Manager', level_name: 'Security Review', required: true });\n    }\n    \n    flow.push({ step: flow.length + 1, approver_role: 'Plant Manager', level_name: 'Final Approval', required: true });\n    return flow;\n  }\n\n  // Travel flow generation\n  private static async generateTravelFlow(policy: any, data: any, customerId: string) {\n    const amount = data.amount || 0;\n    const flow = [];\n    \n    flow.push({ step: 1, approver_role: 'Direct Manager', level_name: 'Manager Approval', required: true });\n    \n    if (amount > 1000) {\n      flow.push({ step: 2, approver_role: 'Department Head', level_name: 'Department Approval', required: true });\n    }\n    \n    if (amount > 5000) {\n      flow.push({ step: 3, approver_role: 'Finance Manager', level_name: 'Finance Approval', required: true });\n    }\n    \n    return flow;\n  }\n\n  // HR flow generation\n  private static async generateHRFlow(policy: any, data: any, customerId: string) {\n    const flow = [];\n    const leaveType = data.leave_type;\n    const days = data.days_requested || 0;\n    \n    flow.push({ step: 1, approver_role: 'Direct Manager', level_name: 'Manager Approval', required: true });\n    \n    if (days > 5 || leaveType === 'SICK') {\n      flow.push({ step: 2, approver_role: 'HR Manager', level_name: 'HR Review', required: true });\n    }\n    \n    return flow;\n  }\n\n  // Default flow generation\n  private static async generateDefaultFlow(policy: any, data: any, customerId: string) {\n    return [{\n      step: 1,\n      approver_role: 'Manager',\n      level_name: 'Manager Approval',\n      required: true\n    }];\n  }\n\n  // Hierarchical flow with HR integration check\n  private static async generateHierarchicalFlow(policy: any, data: any, customerId: string) {\n    // Check if HR integration is available\n    const hrIntegrated = await this.checkHRIntegration(customerId);\n    \n    if (hrIntegrated) {\n      return this.generateHRBasedFlow(policy, data, customerId);\n    } else {\n      return this.generatePositionBasedFlow(policy, data, customerId);\n    }\n  }\n\n  // Check HR system integration\n  private static async checkHRIntegration(customerId: string): Promise<boolean> {\n    try {\n      const employees = await ApprovalRepository.getEmployeeHierarchy(customerId);\n      return employees && employees.length > 0;\n    } catch (error) {\n      return false; // HR not available, use position-based\n    }\n  }\n\n  // HR-based approval flow\n  private static async generateHRBasedFlow(policy: any, data: any, customerId: string) {\n    const requesterEmployeeId = data.requester_employee_id;\n    if (!requesterEmployeeId) {\n      return this.generatePositionBasedFlow(policy, data, customerId);\n    }\n\n    const employeeHierarchy = await ApprovalRepository.getEmployeeHierarchy(customerId);\n    const requester = employeeHierarchy.find(emp => emp.employee_id === requesterEmployeeId);\n    \n    if (!requester) {\n      return this.generatePositionBasedFlow(policy, data, customerId);\n    }\n\n    const flow = [];\n    let currentLevel = requester;\n    let step = 1;\n\n    // Direct Manager\n    if (currentLevel.manager_employee_id) {\n      const manager = employeeHierarchy.find(emp => emp.employee_id === currentLevel.manager_employee_id);\n      if (manager) {\n        flow.push({\n          step: step++,\n          approver_role: manager.position_title,\n          approver_name: manager.employee_name,\n          employee_id: manager.employee_id,\n          level_name: 'Direct Manager Approval',\n          approval_limit: manager.approval_limit,\n          required: true\n        });\n        currentLevel = manager;\n      }\n    }\n\n    // Department Head (if different from manager)\n    if (currentLevel.department_head_id && currentLevel.department_head_id !== currentLevel.employee_id) {\n      const deptHead = employeeHierarchy.find(emp => emp.employee_id === currentLevel.department_head_id);\n      if (deptHead) {\n        flow.push({\n          step: step++,\n          approver_role: deptHead.position_title,\n          approver_name: deptHead.employee_name,\n          employee_id: deptHead.employee_id,\n          level_name: 'Department Head Approval',\n          approval_limit: deptHead.approval_limit,\n          required: true\n        });\n      }\n    }\n\n    // Add functional approvers based on amount/type\n    const functionalApprovers = await this.getFunctionalApproversForRequest(data, customerId);\n    functionalApprovers.forEach(approver => {\n      flow.push({\n        step: step++,\n        approver_role: approver.approver_role,\n        level_name: `${approver.functional_domain} Approval`,\n        approval_limit: approver.approval_limit,\n        required: true\n      });\n    });\n\n    return flow;\n  }\n\n  // Position-based approval flow (no HR)\n  private static async generatePositionBasedFlow(policy: any, data: any, customerId: string) {\n    const orgHierarchy = await ApprovalRepository.getOrganizationalHierarchy(customerId);\n    \n    let hierarchyChain = [];\n    if (data.plant_code) {\n      hierarchyChain = orgHierarchy\n        .filter(h => h.plant_code === data.plant_code || h.department_code === 'EXECUTIVE')\n        .sort((a, b) => a.approval_limit - b.approval_limit)\n        .slice(0, 3);\n    } else {\n      hierarchyChain = orgHierarchy\n        .filter(h => h.department_code === 'OPERATIONS' || h.department_code === 'EXECUTIVE')\n        .sort((a, b) => a.approval_limit - b.approval_limit)\n        .slice(0, 2);\n    }\n    \n    const flow = hierarchyChain.map((person, index) => ({\n      step: index + 1,\n      approver_role: person.position_title,\n      level_name: `${person.position_title} Approval`,\n      approval_limit: person.approval_limit,\n      department: person.department_code,\n      plant: person.plant_code,\n      required: true\n    }));\n\n    // Add functional approvers\n    const functionalApprovers = await this.getFunctionalApproversForRequest(data, customerId);\n    functionalApprovers.forEach(approver => {\n      flow.push({\n        step: flow.length + 1,\n        approver_role: approver.approver_role,\n        level_name: `${approver.functional_domain} Approval`,\n        approval_limit: approver.approval_limit,\n        required: true\n      });\n    });\n\n    return flow;\n  }\n\n  // Get functional approvers based on request type\n  private static async getFunctionalApproversForRequest(data: any, customerId: string) {\n    const functionalApprovers = await ApprovalRepository.getFunctionalApprovers(customerId);\n    const requiredApprovers = [];\n\n    // Safety materials require safety approval\n    if (data.material_category === 'SAFETY' || data.hazardous === true) {\n      const safetyApprover = functionalApprovers.find(a => a.functional_domain === 'SAFETY');\n      if (safetyApprover) requiredApprovers.push(safetyApprover);\n    }\n\n    // High-value items require finance approval\n    if (data.amount && data.amount > 100000) {\n      const financeApprover = functionalApprovers.find(a => a.functional_domain === 'FINANCE');\n      if (financeApprover) requiredApprovers.push(financeApprover);\n    }\n\n    // Technical items require engineering approval\n    if (data.material_category === 'TECHNICAL' || data.engineering_review === true) {\n      const engineeringApprover = functionalApprovers.find(a => a.functional_domain === 'ENGINEERING');\n      if (engineeringApprover) requiredApprovers.push(engineeringApprover);\n    }\n\n    return requiredApprovers;\n  }\n\n  // Calculate estimated approval time\n  private static calculateEstimatedTime(policy: any, flow: any[]): string {\n    const baseTime = flow.length * 24;\n    const category = policy.object_category;\n    \n    const multipliers = {\n      'FINANCIAL': 1.0,\n      'DOCUMENT': 1.5,\n      'STORAGE': 0.5,\n      'TRAVEL': 0.75,\n      'HR': 0.5\n    };\n    \n    const totalHours = baseTime * (multipliers[category] || 1.0);\n    return totalHours < 24 ? `${totalHours} hours` : `${Math.ceil(totalHours / 24)} days`;\n  }\n\n  // Optimized policy retrieval with filtering\n  static async getApprovalPoliciesPaginated(filters: any = {}) {\n    console.log('Business layer: Getting filtered policies:', filters);\n    \n    try {\n      const customerId = filters?.customer_id || DEFAULT_CUSTOMER_ID;\n      this.validateCustomerId(customerId);\n      \n      const sanitizedFilters = this.sanitizeInput(filters);\n      \n      // Use optimized query when object_type is provided\n      if (sanitizedFilters.object_type) {\n        const policies = await ApprovalRepository.getApprovalPoliciesPaginated(\n          customerId, \n          sanitizedFilters.object_type,\n          sanitizedFilters.limit || 50,\n          sanitizedFilters.page ? sanitizedFilters.page * (sanitizedFilters.limit || 50) : 0,\n          sanitizedFilters.document_type\n        );\n        return { success: true, policies };\n      } else {\n        // Return empty array if no object type specified (lazy loading)\n        return { success: true, policies: [] };\n      }\n    } catch (error) {\n      console.error('Business layer error fetching filtered policies:', error);\n      return { success: false, policies: [], message: error instanceof Error ? error.message : 'Failed to fetch policies' };\n    }\n  }\n\n  static async getApprovers(filters: any = {}) {\n    console.log('Business layer: Getting approvers:', filters);\n    \n    try {\n      const customerId = filters?.customer_id || DEFAULT_CUSTOMER_ID;\n      this.validateCustomerId(customerId);\n      \n      const sanitizedFilters = this.sanitizeInput(filters);\n      const approvers = await ApprovalRepository.getFunctionalApprovers(customerId, sanitizedFilters);\n      return { success: true, approvers };\n    } catch (error) {\n      console.error('Business layer error fetching approvers:', error);\n      return { success: false, approvers: [], message: error instanceof Error ? error.message : 'Failed to fetch approvers' };\n    }\n  }\n\n  static async deletePolicy(policyId: string) {\n    console.log('Business layer: Deleting approval policy:', policyId);\n    \n    try {\n      if (!policyId || typeof policyId !== 'string') {\n        return { success: false, message: 'Invalid policy ID' };\n      }\n\n      await ApprovalRepository.deleteApprovalPolicy(policyId);\n      return { success: true, message: 'Policy deleted successfully' };\n    } catch (error) {\n      console.error('Business layer error deleting policy:', error);\n      return { success: false, message: error instanceof Error ? error.message : 'Failed to delete policy' };\n    }\n  }\n\n  static async updatePolicy(policyId: string, data: any) {\n    console.log('Business layer: Updating approval policy:', policyId, data);\n    \n    try {\n      if (!policyId || !data) {\n        return { success: false, message: 'Policy ID and data are required' };\n      }\n\n      const sanitizedData = this.sanitizeInput(data);\n      const policy = await ApprovalRepository.updateApprovalPolicy(policyId, sanitizedData);\n      return { success: true, message: 'Policy updated successfully', policy };\n    } catch (error) {\n      console.error('Business layer error updating policy:', error);\n      return { success: false, message: error instanceof Error ? error.message : 'Failed to update policy' };\n    }\n  }\n}"
  },
  "metadata": {
    "version": "1.0.0",
    "lastWorkingState": true
  }
}